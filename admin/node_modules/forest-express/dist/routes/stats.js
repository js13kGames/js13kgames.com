"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _ = require('lodash');

var auth = require('../services/auth');

var logger = require('../services/logger');

var error = require('../utils/error');

var path = require('../services/path');

var StatSerializer = require('../serializers/stat');

var Schemas = require('../generators/schemas');

var CHART_TYPE_VALUE = 'Value';
var CHART_TYPE_PIE = 'Pie';
var CHART_TYPE_LINE = 'Line';
var CHART_TYPE_LEADERBOARD = 'Leaderboard';
var CHART_TYPE_OBJECTIVE = 'Objective';

module.exports = function Stats(app, model, Implementation, opts) {
  var _this = this;

  var modelName = Implementation.getModelName(model);

  this.get = function (request, response, next) {
    var promise = null;

    function getAssociationModel(schema, associationName) {
      var field = _.find(schema.fields, {
        field: associationName
      });

      var relatedModelName;

      if (field && field.reference) {
        var _field$reference$spli = field.reference.split('.');

        var _field$reference$spli2 = (0, _slicedToArray2["default"])(_field$reference$spli, 1);

        relatedModelName = _field$reference$spli2[0];
      }

      var models = Implementation.getModels();
      return _.find(models, function (currentModel) {
        return Implementation.getModelName(currentModel) === relatedModelName;
      });
    }

    var type = request.body.type;

    if (type === CHART_TYPE_OBJECTIVE) {
      type = CHART_TYPE_VALUE;
    }

    if (type === CHART_TYPE_LEADERBOARD) {
      var schema = Schemas.schemas[model.name];
      var modelRelationship = getAssociationModel(schema, request.body.relationship_field);
      promise = new Implementation.LeaderboardStatGetter(model, modelRelationship, request.body, opts).perform();
    } else {
      promise = new Implementation["".concat(type, "StatGetter")](model, request.body, opts).perform();
    }

    if (!promise) {
      return response.status(400).send({
        error: 'Chart type not found.'
      });
    }

    return promise.then(function (stat) {
      if (request.body.type === CHART_TYPE_OBJECTIVE) {
        stat.value.value = stat.value.countCurrent;
        delete stat.value.countCurrent;
        delete stat.value.countPrevious;
      }

      return new StatSerializer(stat).perform();
    }).then(function (stat) {
      response.send(stat);
    })["catch"](next);
  };

  function getErrorQueryColumnsName(result, keyNames) {
    var message = "The result columns must be named ".concat(keyNames, " instead of '").concat(Object.keys(result).join('\', \''), "'.");
    logger.error("Live Query error: ".concat(message));
    return new error.UnprocessableEntity(message);
  }

  this.getWithLiveQuery = function (request, response, next) {
    return new Implementation.QueryStatGetter(request.body, opts).perform().then(function (result) {
      switch (request.body.type) {
        case CHART_TYPE_VALUE:
          if (result.length) {
            var resultLine = result[0];

            if (resultLine.value === undefined) {
              throw getErrorQueryColumnsName(resultLine, '\'value\'');
            } else {
              result = {
                countCurrent: resultLine.value,
                countPrevious: resultLine.previous
              };
            }
          }

          break;

        case CHART_TYPE_PIE:
        case CHART_TYPE_LEADERBOARD:
          if (result.length) {
            result.forEach(function (resultLine) {
              if (resultLine.value === undefined || resultLine.key === undefined) {
                throw getErrorQueryColumnsName(resultLine, '\'key\', \'value\'');
              }
            });
          }

          break;

        case CHART_TYPE_LINE:
          if (result.length) {
            result.forEach(function (resultLine) {
              if (resultLine.value === undefined || resultLine.key === undefined) {
                throw getErrorQueryColumnsName(resultLine, '\'key\', \'value\'');
              }
            });
          }

          result = result.map(function (resultLine) {
            return {
              label: resultLine.key,
              values: {
                value: resultLine.value
              }
            };
          });
          break;

        case CHART_TYPE_OBJECTIVE:
          if (result.length) {
            var _resultLine = result[0];

            if (_resultLine.value === undefined || _resultLine.objective === undefined) {
              throw getErrorQueryColumnsName(_resultLine, '\'value\', \'objective\'');
            } else {
              result = {
                objective: _resultLine.objective,
                value: _resultLine.value
              };
            }
          }

          break;

        default:
          throw new Error('Unknown Chart type');
      }

      return new StatSerializer({
        value: result
      }).perform();
    }).then(function (data) {
      response.send(data);
    })["catch"](next);
  };

  this.perform = function () {
    app.post(path.generate("stats/".concat(modelName), opts), auth.ensureAuthenticated, _this.get);
    app.post(path.generate('stats', opts), auth.ensureAuthenticated, _this.getWithLiveQuery);
  };
};