{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;AAAA,6BAA+B;AAC/B,uCAAyC;AAEzC,IAAM,GAAG,GAAG,KAAK,CAAC,oBAAoB,CAAC,CAAA;AASvC;;GAEG;AACH,SAAgB,OAAO;IAAmB,kBAA+B;SAA/B,UAA+B,EAA/B,qBAA+B,EAA/B,IAA+B;QAA/B,6BAA+B;;IACvE,IAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAA;IAErC,OAAO,UAAC,GAAM,EAAE,GAAM,EAAE,IAAa,IAAK,OAAA,UAAU,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,EAAhC,CAAgC,CAAA;AAC5E,CAAC;AAJD,0BAIC;AAED;;GAEG;AACH,SAAgB,MAAM;IAAmB,kBAA+B;SAA/B,UAA+B,EAA/B,qBAA+B,EAA/B,IAA+B;QAA/B,6BAA+B;;IACtE,OAAO,QAAQ,CAAC,QAAQ,CAAC,CAAA;AAC3B,CAAC;AAFD,wBAEC;AAED;;GAEG;AACH,SAAS,QAAQ,CAAmB,QAAiC;IACnE,IAAM,KAAK,GAAG,OAAO,CAAsB,QAAQ,CAAC,CAAA;IAEpD,KAAsB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;QAAxB,IAAM,OAAO,cAAA;QAChB,IAAI,OAAO,OAAc,KAAK,UAAU,EAAE;YACxC,MAAM,IAAI,SAAS,CAAC,6BAA6B,CAAC,CAAA;SACnD;KACF;IAED,OAAO,SAAS,UAAU,CAAE,GAAiB,EAAE,GAAM,EAAE,GAAM,EAAE,IAAa;QAC1E,IAAI,KAAK,GAAG,CAAC,CAAC,CAAA;QAEd,SAAS,QAAQ,CAAE,GAAW,EAAE,GAAkB;YAChD,IAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;YAE1B,KAAK,GAAG,GAAG,CAAA;YAEX,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM;gBAAE,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;YAE5C,SAAS,IAAI,CAAE,GAAkB;gBAC/B,IAAI,GAAG,GAAG,KAAK,EAAE;oBACf,MAAM,IAAI,SAAS,CAAC,gCAAgC,CAAC,CAAA;iBACtD;gBAED,OAAO,QAAQ,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,CAAA;YAC/B,CAAC;YAED,IAAI;gBACF,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;oBACxB,IAAI,GAAG,EAAE;wBACP,GAAG,CAAC,aAAa,EAAG,OAAe,CAAC,IAAI,IAAI,aAAa,CAAC,CAAA;wBAE1D,OAAQ,OAAiC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,CAAA;qBAC/D;iBACF;qBAAM;oBACL,IAAI,CAAC,GAAG,EAAE;wBACR,GAAG,CAAC,UAAU,EAAG,OAAe,CAAC,IAAI,IAAI,aAAa,CAAC,CAAA;wBAEvD,OAAQ,OAAmC,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,CAAA;qBAC5D;iBACF;aACF;YAAC,OAAO,CAAC,EAAE;gBACV,0DAA0D;gBAC1D,IAAI,KAAK,GAAG,GAAG;oBAAE,MAAM,CAAC,CAAA;gBAExB,GAAG,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;gBAEpB,OAAO,IAAI,CAAC,CAAC,CAAC,CAAA;aACf;YAED,OAAO,IAAI,CAAC,GAAG,CAAC,CAAA;QAClB,CAAC;QAED,OAAO,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAA;IACzB,CAAC,CAAA;AACH,CAAC","sourcesContent":["import debug = require('debug')\nimport flatten = require('array-flatten')\n\nconst log = debug('compose-middleware')\n\nexport type Next<T = void> = (err?: Error | null) => T\nexport type RequestHandler <T, U, V = void> = (req: T, res: U, next: Next<V>) => V\nexport type ErrorHandler <T, U, V = void> = (err: Error, req: T, res: U, next: Next<V>) => V\nexport type Middleware <T, U, V = void> = RequestHandler<T, U, V> | ErrorHandler<T, U, V>\n\nexport type Handler <T, U, V = void> = Middleware<T, U, V> | flatten.NestedArray<Middleware<T, U, V>>\n\n/**\n * Compose an array of middleware handlers into a single handler.\n */\nexport function compose <T, U, V = void> (...handlers: Handler<T, U, V>[]): RequestHandler<T, U, V> {\n  const middleware = generate(handlers)\n\n  return (req: T, res: U, done: Next<V>) => middleware(null, req, res, done)\n}\n\n/**\n * Wrap middleware handlers.\n */\nexport function errors <T, U, V = void> (...handlers: Handler<T, U, V>[]): ErrorHandler<T, U, V> {\n  return generate(handlers)\n}\n\n/**\n * Generate a composed middleware function.\n */\nfunction generate <T, U, V = void> (handlers: Array<Handler<T, U, V>>) {\n  const stack = flatten<Middleware<T, U, V>>(handlers)\n\n  for (const handler of stack) {\n    if (typeof handler as any !== 'function') {\n      throw new TypeError('Handlers must be a function')\n    }\n  }\n\n  return function middleware (err: Error | null, req: T, res: U, done: Next<V>): V {\n    let index = -1\n\n    function dispatch (pos: number, err?: Error | null): V {\n      const handler = stack[pos]\n\n      index = pos\n\n      if (index === stack.length) return done(err)\n\n      function next (err?: Error | null) {\n        if (pos < index) {\n          throw new TypeError('`next()` called multiple times')\n        }\n\n        return dispatch(pos + 1, err)\n      }\n\n      try {\n        if (handler.length === 4) {\n          if (err) {\n            log('handle(err)', (handler as any).name || '<anonymous>')\n\n            return (handler as ErrorHandler<T, U, V>)(err, req, res, next)\n          }\n        } else {\n          if (!err) {\n            log('handle()', (handler as any).name || '<anonymous>')\n\n            return (handler as RequestHandler<T, U, V>)(req, res, next)\n          }\n        }\n      } catch (e) {\n        // Avoid future errors that could diverge stack execution.\n        if (index > pos) throw e\n\n        log('try..catch', e)\n\n        return next(e)\n      }\n\n      return next(err)\n    }\n\n    return dispatch(0, err)\n  }\n}\n"]}