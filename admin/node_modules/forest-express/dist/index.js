"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var P = require('bluebird');

var _ = require('lodash');

var express = require('express');

var path = require('path');

var fs = require('fs');

var cors = require('cors');

var bodyParser = require('body-parser');

var jwt = require('express-jwt');

var requireAll = require('require-all');

var context = require('./context');

var initContext = require('./context/init');

context.init(initContext);

var auth = require('./services/auth');

var ResourcesRoutes = require('./routes/resources');

var ActionsRoutes = require('./routes/actions');

var AssociationsRoutes = require('./routes/associations');

var StatRoutes = require('./routes/stats');

var SessionRoute = require('./routes/sessions');

var ForestRoutes = require('./routes/forest');

var HealthCheckRoute = require('./routes/healthcheck');

var Schemas = require('./generators/schemas');

var SchemaSerializer = require('./serializers/schema');

var Integrator = require('./integrations');

var ConfigStore = require('./services/config-store');

var ProjectDirectoryUtils = require('./utils/project-directory');

var _require = require('./utils/token-checker'),
    is2FASaltValid = _require.is2FASaltValid;

var _require2 = require('./config/jwt'),
    getJWTConfiguration = _require2.getJWTConfiguration;

var _context$inject = context.inject(),
    logger = _context$inject.logger,
    pathService = _context$inject.pathService,
    errorHandler = _context$inject.errorHandler,
    ipWhitelist = _context$inject.ipWhitelist,
    apimapFieldsFormater = _context$inject.apimapFieldsFormater,
    apimapSender = _context$inject.apimapSender,
    schemaFileUpdater = _context$inject.schemaFileUpdater;

var pathProjectAbsolute = new ProjectDirectoryUtils().getAbsolutePath();
var ENVIRONMENT_DEVELOPMENT = !process.env.NODE_ENV || ['dev', 'development'].includes(process.env.NODE_ENV);
var SCHEMA_FILENAME = "".concat(pathProjectAbsolute, "/.forestadmin-schema.json");
var DISABLE_AUTO_SCHEMA_APPLY = process.env.FOREST_DISABLE_AUTO_SCHEMA_APPLY && JSON.parse(process.env.FOREST_DISABLE_AUTO_SCHEMA_APPLY);
var REGEX_COOKIE_SESSION_TOKEN = /forest_session_token=([^;]*)/;
var TWO_FA_SECRET_SALT = process.env.FOREST_2FA_SECRET_SALT;
var configStore = ConfigStore.getInstance();
var jwtAuthenticator;

function getModels() {
  var models = configStore.Implementation.getModels();

  _.each(models, function (model, modelName) {
    model.modelName = modelName;
  });

  return _.values(models);
}

function requireAllModels(modelsDir) {
  if (modelsDir) {
    try {
      var isJavascriptOrTypescriptFileName = function isJavascriptOrTypescriptFileName(fileName) {
        return fileName.endsWith('.js') || fileName.endsWith('.ts') && !fileName.endsWith('.d.ts');
      }; // NOTICE: Ends with `.spec.js`, `.spec.ts`, `.test.js` or `.test.ts`.


      var isTestFileName = function isTestFileName(fileName) {
        return fileName.match(/(?:\.test|\.spec)\.(?:js||ts)$/g);
      };

      requireAll({
        dirname: modelsDir,
        excludeDirs: /^__tests__$/,
        filter: function filter(fileName) {
          return isJavascriptOrTypescriptFileName(fileName) && !isTestFileName(fileName);
        },
        recursive: true
      });
    } catch (error) {
      logger.error('Cannot read a file for the following reason: ', error);
    }
  } // NOTICE: User didn't provide a modelsDir but may already have required them manually so they
  //         might be available.


  return P.resolve(getModels())["catch"](function (error) {
    logger.error('Cannot read a file for the following reason: ', error);
    return P.resolve([]);
  });
}

exports.Schemas = Schemas;
exports.logger = logger;
exports.ResourcesRoute = {};

exports.ensureAuthenticated = function (request, response, next) {
  auth.authenticate(request, response, next, jwtAuthenticator);
};

var app = null;

function buildSchema() {
  return _buildSchema.apply(this, arguments);
}

function _buildSchema() {
  _buildSchema = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
    var lianaOptions, Implementation, absModelDirs, models;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            lianaOptions = configStore.lianaOptions, Implementation = configStore.Implementation;
            absModelDirs = configStore.modelsDir ? path.resolve('.', configStore.modelsDir) : undefined;
            _context2.next = 4;
            return requireAllModels(absModelDirs);

          case 4:
            models = _context2.sent;
            configStore.integrator = new Integrator(lianaOptions, Implementation);
            _context2.next = 8;
            return Schemas.perform(Implementation, configStore.integrator, models, lianaOptions);

          case 8:
            return _context2.abrupt("return", models);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _buildSchema.apply(this, arguments);
}

function generateAndSendSchema(opts) {
  if (!opts.envSecret) {
    return;
  }

  if (opts.envSecret.length !== 64) {
    logger.error('Your envSecret does not seem to be correct. Can you check on Forest that you copied it properly in the Forest initialization?');
    return;
  }

  var collections = _.values(Schemas.schemas);

  configStore.integrator.defineCollections(collections);
  collections.filter(function (collection) {
    return collection.actions && collection.actions.length;
  }) // NOTICE: Check each Smart Action declaration to detect configuration errors.
  .forEach(function (collection) {
    var isFieldsInvalid = function isFieldsInvalid(action) {
      return action.fields && !Array.isArray(action.fields);
    };

    collection.actions.forEach(function (action) {
      if (!action.name) {
        logger.warn("An unnamed Smart Action of collection \"".concat(collection.name, "\" has been ignored."));
      } else if (isFieldsInvalid(action)) {
        logger.error("Cannot find the fields you defined for the Smart action \"".concat(action.name, "\" of your \"").concat(collection.name, "\" collection. The fields option must be an array."));
      }
    }); // NOTICE: Ignore actions without a name.

    collection.actions = collection.actions.filter(function (action) {
      return action.name;
    });
  });
  var schemaSerializer = new SchemaSerializer();
  var serializerOptions = schemaSerializer.options;
  var collectionsSent;
  var metaSent;

  if (ENVIRONMENT_DEVELOPMENT) {
    var meta = {
      database_type: configStore.Implementation.getDatabaseType(),
      liana: configStore.Implementation.getLianaName(),
      liana_version: configStore.Implementation.getLianaVersion(),
      engine: 'nodejs',
      engine_version: process.versions && process.versions.node,
      orm_version: configStore.Implementation.getOrmVersion()
    };
    var content = schemaFileUpdater.update(SCHEMA_FILENAME, collections, meta, serializerOptions);
    collectionsSent = content.collections;
    metaSent = content.meta;
  } else {
    try {
      var _content = fs.readFileSync(SCHEMA_FILENAME);

      if (!_content) {
        logger.error('The .forestadmin-schema.json file is empty.');
        logger.error('The schema cannot be synchronized with Forest Admin servers.');
        return;
      }

      var contentParsed = JSON.parse(_content.toString());
      collectionsSent = contentParsed.collections;
      metaSent = contentParsed.meta;
    } catch (error) {
      if (error.code === 'ENOENT') {
        logger.error('The .forestadmin-schema.json file does not exist.');
      } else {
        logger.error('The content of .forestadmin-schema.json file is not a correct JSON.');
      }

      logger.error('The schema cannot be synchronized with Forest Admin servers.');
      return;
    }
  }

  if (DISABLE_AUTO_SCHEMA_APPLY) {
    return;
  }

  var schemaSent = schemaSerializer.perform(collectionsSent, metaSent);
  apimapSender.send(opts.envSecret, schemaSent);
}

exports.init = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(Implementation) {
    var opts, pathMounted, allowedOrigins, pathsPublic, models, directorySmartImplementation;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = Implementation.opts;
            configStore.Implementation = Implementation;
            configStore.lianaOptions = opts;

            if (!(opts.onlyCrudModule === true)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", buildSchema());

          case 5:
            if (!app) {
              _context.next = 8;
              break;
            }

            logger.warn('Forest init function called more than once. Only the first call has been processed.');
            return _context.abrupt("return", app);

          case 8:
            app = express();
            pathMounted = pathService.generate('*', opts);
            auth.initAuth(opts);

            if (opts.secretKey) {
              logger.warn('DEPRECATION WARNING: The use of secretKey and authKey options is deprecated. Please use envSecret and authSecret instead.');
              opts.envSecret = opts.secretKey;
              opts.authSecret = opts.authKey;
            }

            if (TWO_FA_SECRET_SALT) {
              try {
                is2FASaltValid(TWO_FA_SECRET_SALT);
              } catch (error) {
                logger.warn(error.message);
              }
            } // CORS


            allowedOrigins = ['localhost:4200', /\.forestadmin\.com$/];

            if (process.env.CORS_ORIGINS) {
              allowedOrigins = allowedOrigins.concat(process.env.CORS_ORIGINS.split(','));
            }

            app.use(pathMounted, cors({
              origin: allowedOrigins,
              maxAge: 86400,
              // NOTICE: 1 day
              credentials: true
            })); // Mime type

            app.use(pathMounted, bodyParser.json()); // Authentication

            if (opts.authSecret) {
              jwtAuthenticator = jwt(getJWTConfiguration({
                secret: opts.authSecret,
                getToken: function getToken(request) {
                  if (request.headers) {
                    if (request.headers.authorization && request.headers.authorization.split(' ')[0] === 'Bearer') {
                      return request.headers.authorization.split(' ')[1];
                    } // NOTICE: Necessary for downloads authentication.


                    if (request.headers.cookie) {
                      var match = request.headers.cookie.match(REGEX_COOKIE_SESSION_TOKEN);

                      if (match && match[1]) {
                        return match[1];
                      }
                    }
                  }

                  return null;
                }
              }));
            } else {
              logger.error('Your Forest authSecret seems to be missing. Can you check that you properly set a Forest authSecret in the Forest initializer?');
            }

            if (!opts.envSecret) {
              logger.error('Your Forest envSecret seems to be missing. Can you check that you properly set a Forest envSecret in the Forest initializer?');
            }

            if (jwtAuthenticator) {
              pathsPublic = [/^\/forest\/sessions.*$/];
              app.use(pathMounted, jwtAuthenticator.unless({
                path: pathsPublic
              }));
            }

            new HealthCheckRoute(app, opts).perform();
            new SessionRoute(app, opts).perform(); // Init

            _context.prev = 22;
            _context.next = 25;
            return buildSchema();

          case 25:
            models = _context.sent;

            if (opts.configDir) {
              directorySmartImplementation = path.resolve('.', opts.configDir);
            } else {
              directorySmartImplementation = "".concat(path.resolve('.'), "/forest");
            }

            if (!fs.existsSync(directorySmartImplementation)) {
              _context.next = 32;
              break;
            }

            _context.next = 30;
            return requireAllModels(directorySmartImplementation);

          case 30:
            _context.next = 33;
            break;

          case 32:
            if (opts.configDir) {
              logger.error('The Forest configDir option you configured does not seem to be an existing directory.');
            }

          case 33:
            models.forEach(function (model) {
              var modelName = configStore.Implementation.getModelName(model);
              configStore.integrator.defineRoutes(app, model, configStore.Implementation);
              var resourcesRoute = new ResourcesRoutes(app, model);
              resourcesRoute.perform();
              exports.ResourcesRoute[modelName] = resourcesRoute;
              new AssociationsRoutes(app, model, configStore.Implementation, configStore.integrator, configStore.lianaOptions).perform();
              new ActionsRoutes().perform(app, model, configStore.Implementation, configStore.lianaOptions, auth);
              new StatRoutes(app, model, configStore.Implementation, configStore.lianaOptions).perform();
            });
            new ForestRoutes(app, configStore.lianaOptions).perform();
            app.use(pathMounted, errorHandler({
              logger: logger
            }));
            generateAndSendSchema(opts);
            _context.prev = 37;
            _context.next = 40;
            return ipWhitelist.retrieve(opts.envSecret);

          case 40:
            _context.next = 44;
            break;

          case 42:
            _context.prev = 42;
            _context.t0 = _context["catch"](37);

          case 44:
            if (opts.expressParentApp) {
              opts.expressParentApp.use('/forest', app);
            }

            return _context.abrupt("return", app);

          case 48:
            _context.prev = 48;
            _context.t1 = _context["catch"](22);
            logger.error('An error occured while computing the Forest schema. Your application schema cannot be synchronized with Forest. Your admin panel might not reflect your application models definition. ', _context.t1);
            throw _context.t1;

          case 52:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[22, 48], [37, 42]]);
  }));

  return function (_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.collection = function (name, opts) {
  if (_.isEmpty(Schemas.schemas) && opts.modelsDir) {
    logger.error("Cannot customize your collection named \"".concat(name, "\" properly. Did you call the \"collection\" method in the /forest directory?"));
    return;
  }

  var collection = _.find(Schemas.schemas, {
    name: name
  });

  if (!collection) {
    collection = _.find(Schemas.schemas, {
      nameOld: name
    });

    if (collection) {
      name = collection.name;
      logger.warn("DEPRECATION WARNING: Collection names are now based on the models names. Please rename the collection \"".concat(collection.nameOld, "\" of your Forest customisation in \"").concat(collection.name, "\"."));
    }
  }

  if (collection) {
    if (!Schemas.schemas[name].actions) {
      Schemas.schemas[name].actions = [];
    }

    if (!Schemas.schemas[name].segments) {
      Schemas.schemas[name].segments = [];
    }

    Schemas.schemas[name].actions = _.union(opts.actions, Schemas.schemas[name].actions);
    Schemas.schemas[name].segments = _.union(opts.segments, Schemas.schemas[name].segments); // NOTICE: Smart Field definition case

    opts.fields = apimapFieldsFormater.formatFieldsByCollectionName(opts.fields, name);
    Schemas.schemas[name].fields = _.concat(opts.fields, Schemas.schemas[name].fields);

    if (opts.searchFields) {
      Schemas.schemas[name].searchFields = opts.searchFields;
    }
  } else if (opts.fields && opts.fields.length) {
    // NOTICE: Smart Collection definition case
    opts.name = name;
    opts.idField = 'id';
    opts.isVirtual = true;
    opts.isSearchable = !!opts.isSearchable;
    opts.fields = apimapFieldsFormater.formatFieldsByCollectionName(opts.fields, name);
    Schemas.schemas[name] = opts;
  }
};

exports.StatSerializer = require('./serializers/stat');
exports.ResourceSerializer = require('./serializers/resource');
exports.ResourceDeserializer = require('./deserializers/resource');
exports.BaseFiltersParser = require('./services/base-filters-parser');
exports.BaseOperatorDateParser = require('./services/base-operator-date-parser');
exports.RecordsGetter = require('./services/exposed/records-getter');
exports.RecordsCounter = require('./services/exposed/records-counter');
exports.RecordsExporter = require('./services/exposed/records-exporter');
exports.RecordGetter = require('./services/exposed/record-getter');
exports.RecordUpdater = require('./services/exposed/record-updater');
exports.RecordCreator = require('./services/exposed/record-creator');
exports.RecordRemover = require('./services/exposed/record-remover');
exports.RecordsRemover = require('./services/exposed/records-remover');
exports.RecordSerializer = require('./services/exposed/record-serializer');
exports.PermissionMiddlewareCreator = require('./middlewares/permissions');
exports.errorHandler = errorHandler;
exports.PUBLIC_ROUTES = ['/', '/healthcheck', '/sessions', '/sessions-google'];