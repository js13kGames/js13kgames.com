"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _ = require('lodash');

var P = require('bluebird');

var logger = require('../services/logger');

var Schemas = require('../generators/schemas');

var DEPTH_MAX_FOR_INJECTION = 0;

function SmartFieldsValuesInjector(record, modelName, fieldsPerModel) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var requestedField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var schema = Schemas.schemas[modelName];
  var fieldsForHighlightedSearch = [];

  this.getFieldsForHighlightedSearch = function () {
    return fieldsForHighlightedSearch;
  }; // NOTICE: Field reference format: `modelName.property`.


  function getReferencedModelName(field) {
    return field.reference.split('.')[0];
  } // eslint-disable-next-line


  function setSmartFieldValue(record, field, modelName) {
    if (field.value) {
      logger.warn("DEPRECATION WARNING: Smart Fields \"value\" method is deprecated. Please use \"get\" method in your collection ".concat(modelName, " instead."));
    }

    var value;

    try {
      value = field.get ? field.get(record) : field.value(record);
    } catch (error) {
      logger.error("Cannot retrieve the ".concat(field.field, " value because of an internal error in the getter implementation: "), error);
    }

    if (!_.isNil(value)) {
      if (!_.isFunction(value.then)) {
        value = Promise.resolve(value);
      }

      return value.then( /*#__PURE__*/function () {
        var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(smartFieldValue) {
          var smartFieldsValuesInjector;
          return _regenerator["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(depth <= DEPTH_MAX_FOR_INJECTION && smartFieldValue && smartFieldValue.dataValues && field.reference)) {
                    _context.next = 4;
                    break;
                  }

                  smartFieldsValuesInjector = new SmartFieldsValuesInjector(smartFieldValue, getReferencedModelName(field), fieldsPerModel, depth + 1, field.field);
                  _context.next = 4;
                  return smartFieldsValuesInjector.perform();

                case 4:
                  // NOTICE: Update the record with the the Smart Field value.
                  //         Take note it will not be inserted in record dataValues
                  //         as it is an extra field (not from the DB)
                  record[field.field] = smartFieldValue; // NOTICE: String fields can be highlighted.

                  if (field.type === 'String') {
                    fieldsForHighlightedSearch.push(field.field);
                  }

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }())["catch"](function (error) {
        logger.warn("Cannot set the ".concat(field.field, " value because of an unexpected error: "), error);
      });
    }
  }

  function isNotRequestedField(modelNameToCheck, fieldName) {
    return fieldsPerModel && fieldsPerModel[modelNameToCheck] && fieldsPerModel[modelNameToCheck].indexOf(fieldName) === -1;
  }

  this.perform = function () {
    return P.each(schema.fields, function (field) {
      if (record && record.dataValues && !Object.prototype.hasOwnProperty.call(record.dataValues, field.field)) {
        if (field.get || field.value) {
          if (isNotRequestedField(requestedField || modelName, field.field)) {
            return null;
          }

          return setSmartFieldValue(record, field, modelName);
        }

        if (_.isArray(field.type)) {
          // NOTICE: when modifying a sequelize record, make sure you pass the same reference
          //         to record and record.dataValues
          var emptyArray = [];
          record[field.field] = emptyArray;
          record.setDataValue(field.field, emptyArray);
        }
      } else if (field.reference && !_.isArray(field.type)) {
        // NOTICE: Set Smart Fields values to "belongsTo" associated records.
        var modelNameAssociation = getReferencedModelName(field);
        var schemaAssociation = Schemas.schemas[modelNameAssociation];

        if (schemaAssociation && !_.isArray(field.type)) {
          return P.each(schemaAssociation.fields, function (fieldAssociation) {
            if (isNotRequestedField(field.field, fieldAssociation.field)) {
              return null;
            }

            if (record && record[field.field] && record[field.field].dataValues && !Object.prototype.hasOwnProperty.call(record[field.field].dataValues, fieldAssociation.field) && (fieldAssociation.get || fieldAssociation.value)) {
              return setSmartFieldValue(record[field.field], fieldAssociation, modelNameAssociation);
            }

            return null;
          });
        }
      }

      return null;
    }).thenReturn(record);
  };
}

module.exports = SmartFieldsValuesInjector;