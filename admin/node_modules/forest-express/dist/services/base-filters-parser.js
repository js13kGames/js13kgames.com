"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _error = require("../utils/error");

// NOTICE: Parse the given filters into a valid JSON.
var parseFiltersString = function parseFiltersString(filtersString) {
  try {
    return filtersString ? JSON.parse(filtersString) : null;
  } catch (error) {
    throw new _error.InvalidFiltersFormat('Invalid filters JSON format');
  }
}; // NOTICE: Apply the formatCondition function to a condition (leaf).


var parseCondition = /*#__PURE__*/function () {
  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(condition, formatCondition) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!_lodash["default"].isEmpty(condition)) {
              _context.next = 2;
              break;
            }

            throw new _error.InvalidFiltersFormat('Empty condition in filter');

          case 2:
            if (_lodash["default"].isObject(condition)) {
              _context.next = 4;
              break;
            }

            throw new _error.InvalidFiltersFormat('Condition cannot be a raw value');

          case 4:
            if (!_lodash["default"].isArray(condition)) {
              _context.next = 6;
              break;
            }

            throw new _error.InvalidFiltersFormat('Filters cannot be a raw array');

          case 6:
            if (!(!_lodash["default"].isString(condition.field) || !_lodash["default"].isString(condition.operator) || _lodash["default"].isUndefined(condition.value))) {
              _context.next = 8;
              break;
            }

            throw new _error.InvalidFiltersFormat('Invalid condition format');

          case 8:
            return _context.abrupt("return", formatCondition(condition));

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function parseCondition(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}(); // NOTICE: Call the formatAggregation function on the node and propagate it to its childs or
//         call the parseCondition function on the node if the node is a leaf.


var parseAggregation = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(node, formatAggregation, formatCondition) {
    var promises, formatedConditions;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!_lodash["default"].isEmpty(node)) {
              _context2.next = 2;
              break;
            }

            throw new _error.InvalidFiltersFormat('Empty condition in filter');

          case 2:
            if (_lodash["default"].isObject(node)) {
              _context2.next = 4;
              break;
            }

            throw new _error.InvalidFiltersFormat('Filters cannot be a raw value');

          case 4:
            if (!_lodash["default"].isArray(node)) {
              _context2.next = 6;
              break;
            }

            throw new _error.InvalidFiltersFormat('Filters cannot be a raw array');

          case 6:
            if (node.aggregator) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", parseCondition(node, formatCondition));

          case 8:
            if (_lodash["default"].isArray(node.conditions)) {
              _context2.next = 10;
              break;
            }

            throw new _error.InvalidFiltersFormat('Filters\' conditions must be an array');

          case 10:
            promises = [];
            node.conditions.forEach(function (condition) {
              return promises.push(parseAggregation(condition, formatAggregation, formatCondition));
            });
            _context2.next = 14;
            return Promise.all(promises);

          case 14:
            formatedConditions = _context2.sent;
            return _context2.abrupt("return", formatAggregation(node.aggregator, formatedConditions));

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function parseAggregation(_x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}(); // NOTICE: Recursively call the formatAggregation function on the nodes of the filters tree and
//         propagate the formatCondition function to the leaves.


var perform = /*#__PURE__*/function () {
  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(filtersString, formatAggregation, formatCondition) {
    var filters;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            filters = parseFiltersString(filtersString);

            if (filters) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return", null);

          case 3:
            return _context3.abrupt("return", parseAggregation(filters, formatAggregation, formatCondition));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function perform(_x6, _x7, _x8) {
    return _ref3.apply(this, arguments);
  };
}();

var getConditionAssociation = function getConditionAssociation(condition) {
  var splittedField = condition.field.split(':');
  return splittedField.length > 1 ? splittedField[0] : null;
};

var aggregateAssociations = function aggregateAssociations(_aggregator, conditionsAssociations) {
  return _lodash["default"].flatten(conditionsAssociations);
}; // NOTICE: Recursively populate the associations names from the filters.


var getAssociations = /*#__PURE__*/function () {
  var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(filtersString) {
    var associations;
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return perform(filtersString, aggregateAssociations, getConditionAssociation);

          case 2:
            associations = _context4.sent;

            if (_lodash["default"].isArray(associations)) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt("return", associations ? [associations] : []);

          case 5:
            return _context4.abrupt("return", _lodash["default"].uniq(_lodash["default"].compact(associations)));

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function getAssociations(_x9) {
    return _ref4.apply(this, arguments);
  };
}();

module.exports = {
  perform: perform,
  parseFiltersString: parseFiltersString,
  getAssociations: getAssociations
};