"use strict";

var _ = require('lodash');

var P = require('bluebird');

var logger = require('../../../services/logger');

var ContactGetter = require('./contact-getter');

function ConversationsGetter(Implementation, params, opts, mappingValue) {
  var Intercom = opts.integrations.intercom.intercom;
  var intercom = new Intercom.Client(opts.integrations.intercom.credentials);

  function hasPagination() {
    return params.page && params.page.number;
  }

  function getLimit() {
    return 5;
  }

  function getSkip() {
    if (hasPagination()) {
      return (parseInt(params.page.number, 10) - 1) * getLimit();
    }

    return 0;
  }

  function getLink(conversation) {
    return "https://api.intercom.io/conversations/".concat(conversation.id);
  }

  function fetchPages(pages, conversations) {
    return intercom.nextPage(pages).then(function (response) {
      conversations = conversations.concat(response.body.conversations);

      if (response.body.pages.next) {
        return fetchPages(response.pages);
      }

      return conversations;
    });
  } // NOTICE: Forcing the usage of bluebird to avoid issues with the spread on route file


  this.perform = function () {
    return P.resolve(ContactGetter.getContact(intercom, Implementation, mappingValue, params.recordId).then(function (contact) {
      if (!contact || !contact.body || !contact.body.data || !contact.body.data[0]) {
        logger.error('Cannot access to Intercom conversations: No intercom contact matches the given key');
        return [0, []];
      }

      return intercom.conversations.list({
        email: contact.body.data[0].email,
        type: 'user',
        display_as: 'plaintext'
      }).then(function (response) {
        var conversations = response.body.conversations;

        if (response.body.pages.next) {
          return fetchPages(response.body.pages, conversations);
        }

        return conversations;
      }).then(function (conversations) {
        return [conversations.length, conversations.slice(getSkip(), getSkip() + getLimit())];
      }).spread(function (count, conversations) {
        return intercom.admins.list().then(function (response) {
          var admins = response.body.admins;
          return P.map(conversations, function (conversation) {
            if (conversation.assignee && conversation.assignee.type === 'admin') {
              var adminId = parseInt(conversation.assignee.id, 10);

              var admin = _.find(admins, {
                id: adminId
              });

              conversation.assignee = admin;
            }

            if (opts.integrations.intercom.apiKey) {
              conversation.link = getLink(conversation);
            }

            return conversation;
          }).then(function (conversationsFormatted) {
            return [count, conversationsFormatted];
          });
        });
      })["catch"](function (error) {
        try {
          logger.error("Cannot access to Intercom conversations: ".concat(error.body.errors[0].message));
        } catch (tryError) {
          logger.error('Cannot access to Intercom conversations: ', error);
        }

        return [0, []];
      });
    }));
  };
}

module.exports = ConversationsGetter;