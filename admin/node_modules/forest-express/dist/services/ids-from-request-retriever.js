"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var QueryDeserializer = require('../deserializers/query');

var BATCH_PAGE_SIZE = 1000;

function IdsFromRequestRetriever(recordsGetter, recordsCounter, primaryKeysGetter) {
  this.perform = /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params) {
      var hasBodyAttributes, attributes, isSelectAllRecordsQuery, _primaryKeysGetter, primaryKeys, getId, recordsCount, recordsIds, idsExcludedAsString;

      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              hasBodyAttributes = params.body && params.body.data && params.body.data.attributes;
              attributes = hasBodyAttributes && new QueryDeserializer(params.body.data.attributes).perform();
              isSelectAllRecordsQuery = hasBodyAttributes && attributes.allRecords === true; // NOTICE: If it is not a "select all records" query and it receives a list of ID.

              if (!(!isSelectAllRecordsQuery && attributes.ids)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("return", attributes.ids);

            case 5:
              // NOTICE: Build id from primary keys (there can be multiple primary keys).
              //         See: https://github.com/ForestAdmin/forest-express-sequelize/blob/42283494de77c9cebe96adbe156caa45c86a80fa/src/services/composite-keys-manager.js#L24-L40
              _primaryKeysGetter = primaryKeysGetter(), primaryKeys = _primaryKeysGetter.primaryKeys;

              getId = function getId(record) {
                return (// NOTICE: Primary keys are not available in mongoose schemas.
                  primaryKeys ? primaryKeys.map(function (primaryKey) {
                    return record[primaryKey];
                  }).join('-') : record._id
                );
              }; // NOTICE: Get records count


              _context2.next = 9;
              return recordsCounter(attributes);

            case 9:
              recordsCount = _context2.sent;
              _context2.next = 12;
              return Array.from({
                length: Math.ceil(recordsCount / BATCH_PAGE_SIZE)
              }).reduce( /*#__PURE__*/function () {
                var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(accumulator, _, index) {
                  var currentRecords;
                  return _regenerator["default"].wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return recordsGetter(_objectSpread(_objectSpread({}, attributes), {}, {
                            // NOTICE: Try to sort to avoid unexpected order result. Since sequelize and mongoose
                            //         lianas do not support multiple sort, we take first primary key only.
                            sort: primaryKeys ? primaryKeys[0] : '_id',
                            page: {
                              number: "".concat(index + 1),
                              size: "".concat(BATCH_PAGE_SIZE)
                            }
                          }));

                        case 2:
                          currentRecords = _context.sent;
                          _context.t0 = [];
                          _context.t1 = _toConsumableArray2["default"];
                          _context.next = 7;
                          return accumulator;

                        case 7:
                          _context.t2 = _context.sent;
                          _context.t3 = (0, _context.t1)(_context.t2);
                          _context.t4 = (0, _toConsumableArray2["default"])(currentRecords.map(function (record) {
                            return getId(record);
                          }));
                          return _context.abrupt("return", _context.t0.concat.call(_context.t0, _context.t3, _context.t4));

                        case 11:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x2, _x3, _x4) {
                  return _ref2.apply(this, arguments);
                };
              }(), []);

            case 12:
              recordsIds = _context2.sent;

              if (!attributes.allRecordsIdsExcluded) {
                _context2.next = 16;
                break;
              }

              // NOTICE: Ensure that IDs are comparables (avoid ObjectId or Integer issues).
              idsExcludedAsString = attributes.allRecordsIdsExcluded.map(String);
              return _context2.abrupt("return", recordsIds.filter(function (id) {
                return !idsExcludedAsString.includes(String(id));
              }));

            case 16:
              return _context2.abrupt("return", recordsIds);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}

module.exports = IdsFromRequestRetriever;